<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Bambu Timelapse Filter</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; padding: 20px; background-color: #f4f4f9; color: #333; }
        .container { max-width: 600px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        h1, h3 { text-align: center; }
        canvas { max-width: 100%; border: 1px solid #ccc; touch-action: none; display: block; margin: 0 auto; }
        .controls { margin-top: 20px; }
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="range"] { width: 100%; }
        button { padding: 12px 20px; font-size: 16px; width: 100%; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; }
        button:disabled { background-color: #ccc; }
        #status { margin-top: 20px; text-align: center; }
        .hidden { display: none; }
        #progress-container { width: 100%; background-color: #ddd; border-radius: 4px; overflow: hidden; margin-top: 10px; }
        #progress-bar { width: 0%; height: 20px; background-color: #28a745; transition: width 0.3s; }
        .file-input-wrapper { text-align: center; margin: 20px 0; }
        input[type="file"] { padding: 10px; }
        #color-swatch { width: 100%; height: 40px; border-radius: 4px; border: 1px solid #ddd; background-color: #ccc; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Timelapse Filter</h1>

        <div id="upload-section">
            <div class="file-input-wrapper">
                <input type="file" id="video-input" accept="video/*">
            </div>
            <button onclick="uploadVideo()" id="upload-btn">Upload Video</button>
            <p id="upload-status"></p>
        </div>

        <div id="config-section" class="hidden">
            <h3>Configure</h3>
            <p style="text-align: center; font-size: 0.9em; color: #666;">Tap to pick target color. Drag to select Region of Interest (ROI).</p>
            <canvas id="preview-canvas"></canvas>

            <div class="controls">
                <div class="control-group">
                    <label>Selected Color:</label>
                    <div id="color-swatch"></div>
                </div>

                <div class="control-group">
                    <label>Color Tolerance: <span id="tol-val">0.2</span></label>
                    <input type="range" id="color-tolerance" min="0.01" max="0.5" step="0.01" value="0.2" oninput="updateLabel('tol-val', this.value)">
                </div>

                <div class="control-group">
                    <label>Target Radius: <span id="rad-val">20</span>px</label>
                    <input type="range" id="target-radius" min="5" max="100" value="20" oninput="updateLabel('rad-val', this.value)">
                </div>

                <div class="control-group">
                    <label>Radius Tolerance: <span id="rad-tol-val">0.2</span></label>
                    <input type="range" id="radius-tolerance" min="0.01" max="1.0" step="0.01" value="0.2" oninput="updateLabel('rad-tol-val', this.value)">
                </div>

                <button onclick="startProcessing()" id="process-btn">Start Processing</button>
            </div>
        </div>

        <div id="process-section" class="hidden">
            <h3>Processing...</h3>
            <div id="progress-container">
                <div id="progress-bar"></div>
            </div>
            <p id="progress-text">0%</p>
        </div>

        <div id="result-section" class="hidden">
            <h3>Complete!</h3>
            <button onclick="downloadVideo()" id="download-btn">Download Processed Video</button>
            <button onclick="location.reload()" style="background-color: #6c757d; margin-top: 10px;">Start Over</button>
        </div>
    </div>

    <script>
        let filename = null;
        let originalWidth = 0;
        let originalHeight = 0;
        let scaleX = 1;
        let scaleY = 1;
        let img = new Image();
        let canvas = document.getElementById('preview-canvas');
        let ctx = canvas.getContext('2d');
        let roi = null; // [top, bottom, left, right] relative to original image
        let selectedColor = [0, 255, 0]; // Default Green

        // Interaction state
        let isDragging = false;
        let startX, startY;

        function updateLabel(id, value) {
            document.getElementById(id).innerText = value;
        }

        async function uploadVideo() {
            const input = document.getElementById('video-input');
            if (input.files.length === 0) {
                alert("Please select a file.");
                return;
            }

            const file = input.files[0];
            const formData = new FormData();
            formData.append('video', file);

            document.getElementById('upload-btn').disabled = true;
            document.getElementById('upload-status').innerText = "Uploading...";

            try {
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });
                const data = await response.json();

                if (data.error) {
                    alert(data.error);
                    document.getElementById('upload-btn').disabled = false;
                    document.getElementById('upload-status').innerText = "";
                    return;
                }

                filename = data.filename;
                originalWidth = data.width;
                originalHeight = data.height;

                img.onload = () => {
                    initCanvas();
                    document.getElementById('upload-section').classList.add('hidden');
                    document.getElementById('config-section').classList.remove('hidden');
                };
                img.src = "data:image/jpeg;base64," + data.frame_data;

            } catch (e) {
                alert("Upload failed: " + e);
                document.getElementById('upload-btn').disabled = false;
            }
        }

        function initCanvas() {
            // Fit canvas to container width, maintain aspect ratio
            const containerWidth = document.querySelector('.container').clientWidth - 40; // padding
            const aspect = originalWidth / originalHeight;

            canvas.width = containerWidth;
            canvas.height = containerWidth / aspect;

            scaleX = originalWidth / canvas.width;
            scaleY = originalHeight / canvas.height;

            // Default ROI: Full frame
            roi = [0, originalHeight, 0, originalWidth];

            draw();

            // Event Listeners
            canvas.addEventListener('mousedown', onDown);
            canvas.addEventListener('mousemove', onMove);
            canvas.addEventListener('mouseup', onUp);
            canvas.addEventListener('touchstart', onDown, {passive: false});
            canvas.addEventListener('touchmove', onMove, {passive: false});
            canvas.addEventListener('touchend', onUp, {passive: false});
        }

        function draw() {
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            // Draw ROI
            if (roi) {
                const [top, bottom, left, right] = roi;
                const x = left / scaleX;
                const y = top / scaleY;
                const w = (right - left) / scaleX;
                const h = (bottom - top) / scaleY;

                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);

                // Dim outside
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0, 0, canvas.width, y); // Top
                ctx.fillRect(0, y + h, canvas.width, canvas.height - (y + h)); // Bottom
                ctx.fillRect(0, y, x, h); // Left
                ctx.fillRect(x + w, y, canvas.width - (x + w), h); // Right
            }
        }

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX = e.clientX;
            let clientY = e.clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else if (e.changedTouches && e.changedTouches.length > 0) {
                 clientX = e.changedTouches[0].clientX;
                 clientY = e.changedTouches[0].clientY;
            }
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function onDown(e) {
            e.preventDefault();
            isDragging = true;
            const pos = getPos(e);
            startX = pos.x;
            startY = pos.y;
        }

        function onMove(e) {
            e.preventDefault();
            if (!isDragging) return;
            const pos = getPos(e);

            // Temporary ROI drawing logic could go here if we want live drag preview
            // For now, let's just redraw a selection box
            draw();
            const w = pos.x - startX;
            const h = pos.y - startY;
            ctx.strokeStyle = 'yellow';
            ctx.lineWidth = 2;
            ctx.strokeRect(startX, startY, w, h);
        }

        function onUp(e) {
            e.preventDefault();
            if (!isDragging) return;
            isDragging = false;
            const pos = getPos(e);

            const dist = Math.sqrt(Math.pow(pos.x - startX, 2) + Math.pow(pos.y - startY, 2));

            if (dist < 10) {
                // Click/Tap: Pick Color
                pickColor(pos.x, pos.y);
            } else {
                // Drag: Set ROI
                setROI(startX, startY, pos.x, pos.y);
            }
        }

        function pickColor(x, y) {
            // Get pixel data from image (scaled)
            // We need to map canvas coord to image coord
            const imgX = Math.floor(x * scaleX);
            const imgY = Math.floor(y * scaleY);

            // Draw temp canvas to get pixel data from original image?
            // Or just get from canvas since it shows the image.
            // Canvas has resized image, so colors might be slightly interpolated.
            // Better to use canvas data for visual feedback.
            const pixel = ctx.getImageData(x, y, 1, 1).data;
            selectedColor = [pixel[0], pixel[1], pixel[2]]; // RGB

            // BGR for OpenCV
            // Backend expects RGB?
            // wait, core.py expects BGR: `self.target_color_bgr`.
            // And `web_app.py` receives `color` from JSON.
            // `web_app.py`: `color = tuple(data.get('color'))`.
            // If I send RGB from here, I should convert to BGR in backend OR send BGR from here.
            // Let's send [B, G, R] from here to match `core.py`.

            const colorBox = document.getElementById('color-swatch');
            colorBox.style.backgroundColor = `rgb(${pixel[0]}, ${pixel[1]}, ${pixel[2]})`;
        }

        function setROI(x1, y1, x2, y2) {
            let left = Math.min(x1, x2);
            let right = Math.max(x1, x2);
            let top = Math.min(y1, y2);
            let bottom = Math.max(y1, y2);

            // Convert to original coordinates
            left = Math.floor(left * scaleX);
            right = Math.floor(right * scaleX);
            top = Math.floor(top * scaleY);
            bottom = Math.floor(bottom * scaleY);

            // Bounds check
            left = Math.max(0, left);
            top = Math.max(0, top);
            right = Math.min(originalWidth, right);
            bottom = Math.min(originalHeight, bottom);

            if (right - left > 10 && bottom - top > 10) {
                roi = [top, bottom, left, right];
                draw();
            }
        }

        async function startProcessing() {
            const colorTol = parseFloat(document.getElementById('color-tolerance').value);
            const radius = parseInt(document.getElementById('target-radius').value);
            const radiusTol = parseFloat(document.getElementById('radius-tolerance').value);

            // Prepare Color for Backend (BGR)
            const bgrColor = [selectedColor[2], selectedColor[1], selectedColor[0]];

            const payload = {
                filename: filename,
                roi: roi,
                color: bgrColor,
                color_tolerance: colorTol,
                target_radius: radius,
                radius_tolerance: radiusTol
            };

            document.getElementById('config-section').classList.add('hidden');
            document.getElementById('process-section').classList.remove('hidden');

            try {
                const response = await fetch('/process', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();

                if (data.task_id) {
                    pollStatus(data.task_id);
                } else {
                    alert("Error starting process");
                }
            } catch (e) {
                alert("Error: " + e);
            }
        }

        function pollStatus(taskId) {
            const interval = setInterval(async () => {
                try {
                    const response = await fetch(`/status/${taskId}`);
                    const data = await response.json();

                    if (data.status === 'processing') {
                        const pct = data.progress;
                        document.getElementById('progress-bar').style.width = pct + '%';
                        document.getElementById('progress-text').innerText = pct + '%';
                    } else if (data.status === 'completed') {
                        clearInterval(interval);
                        document.getElementById('process-section').classList.add('hidden');
                        document.getElementById('result-section').classList.remove('hidden');

                        // Set download button action
                        const btn = document.getElementById('download-btn');
                        btn.onclick = () => {
                            window.location.href = `/download/${data.output_file}`;
                        };
                    } else if (data.status === 'error') {
                        clearInterval(interval);
                        alert("Processing Error: " + data.error);
                        document.getElementById('process-section').classList.add('hidden');
                        document.getElementById('config-section').classList.remove('hidden');
                    }
                } catch (e) {
                    console.error(e);
                }
            }, 1000);
        }

        function downloadVideo() {
            // Handled in pollStatus
        }

    </script>
</body>
</html>
